<!-- f3399a49-7bbd-45bd-bb1f-76cf9c9be1d2 8040f4c1-7400-429a-853d-0d19411e576f -->
# Milestone 4 — Persistence + Outbox + SSE Backfill

## Scope

Add durable event storage (runs, run_events, run_outbox) to Prisma schema. Replace in-memory delivery with: persist → outbox publisher → event bus → SSE. Support SSE reconnect with `?fromSeq=` backfill. Keep M3 orchestrator unchanged.

## Non-Goals

- No retry/backoff logic (policy stubs only)
- No real device/LLM adapters (M5+)
- No advanced observability (basic metrics only)
- No UI changes (stream contract unchanged)

## Architecture

### Data Model (Prisma)

**runs table:**

- `id` (String @id; runId from M3)
- `state` (String; started | finished | cancelled)
- `startedAt`, `finishedAt` (DateTime)
- `lastSeq` (Int; monotonic per run)
- `v` (Int; schema version)
- `createdAt`, `updatedAt`

**run_events table:**

- `id` (String @id @default(cuid()))
- `runId` (String; FK → runs.id)
- `seq` (Int; per-run monotonic, starts at 1)
- `ts` (BigInt; epoch ms from clock)
- `type` (String; RunStarted | NodeStarted | DebugTrace | NodeFinished | RunFinished)
- `v` (Int; event schema version = 1)
- `source` (String; api | worker | outbox)
- `name` (String?; node name for NodeStarted/Finished)
- `fn` (String?; function id for DebugTrace)
- `publishedAt` (DateTime?; null until outbox publishes)
- `createdAt` (DateTime)
- Unique: `@@unique([runId, seq])`
- Index: `@@index([runId, publishedAt])`

**run_outbox table:**

- `runId` (String @id; PK)
- `nextSeq` (Int @default(1); cursor for outbox)
- `updatedAt` (DateTime)

### Write Path (Strict Order)

1. **Orchestrator emits** → FeatureLayerTracer receives canonical event
2. **Persist to DB:** insert into `run_events` with unique (runId, seq); atomically bump `runs.lastSeq`
3. **No bus publish** at this step (M4 change from M3)
4. **Outbox publishes:** separate worker reads unpublished events in order, publishes to bus, marks `publishedAt`

### Outbox Publisher

**Worker:** `packages/features/agents-run/src/infra/workers/outbox-publisher.ts`

**Algorithm (per run):**

1. Query `run_outbox` for runs with unpublished events (optimistic: nextSeq <= runs.lastSeq)
2. For each run: lock `run_outbox` row, read event at `seq = nextSeq`
3. If event exists and `publishedAt IS NULL`:

- Publish to event bus
- Update `publishedAt = now()`
- Increment `run_outbox.nextSeq`
- If event is `RunFinished`: set `runs.state='finished'`, `finishedAt`

4. Release lock

**Concurrency:** Multiple outbox workers OK; row-level lock ensures one worker per run

### SSE Backfill

**Endpoint:** `GET /agents/runs/:id/stream?fromSeq=<n>`

**Algorithm:**

1. Parse `fromSeq` query param (default: 0)
2. **Backfill:** stream events from `run_events` WHERE `runId = :id AND seq > fromSeq AND publishedAt IS NOT NULL` ORDER BY seq
3. **Attach live:** subscribe to event bus topic for that runId
4. **De-dupe:** track `lastSentSeq`; drop live events if `seq <= lastSentSeq`
5. **Terminal:** close stream after sending `RunFinished`
6. **Heartbeat:** send SSE comment every 15s (does not advance seq)

## File Layout (Authoritative)

### Prisma Schema

- `packages/database/prisma/schema.prisma` — add Run, RunEvent, RunOutbox models at end

### Repositories

- `packages/features/agents-run/src/infra/repos/run-repo.ts`
- `createRun(runId): Promise<void>` — insert runs row with state='started'
- `updateRunState(runId, state, finishedAt?): Promise<void>` — set state/finishedAt
- `getRunLastSeq(runId): Promise<number>` — read lastSeq
- `packages/features/agents-run/src/infra/repos/run-event-repo.ts`
- `appendEvent(event): Promise<void>` — insert run_events; bump runs.lastSeq in transaction
- `getUnpublishedEvents(runId, fromSeq): Promise<AgentEvent[]>` — for backfill
- `markPublished(runId, seq): Promise<void>` — set publishedAt
- `packages/features/agents-run/src/infra/repos/outbox-repo.ts`
- `getNextSeq(runId): Promise<number>` — read run_outbox.nextSeq
- `advanceSeq(runId): Promise<void>` — increment nextSeq
- `initOutbox(runId): Promise<void>` — insert run_outbox row (nextSeq=1)

### Adapters (update)

- `packages/features/agents-run/src/infra/workers/adapters.ts`
- Update `FeatureLayerTracer.emit()` to call `RunEventRepo.appendEvent()` instead of direct bus publish
- Remove direct bus publish; persistence only in M4

### Outbox Publisher

- `packages/features/agents-run/src/infra/workers/outbox-publisher.ts`
- `startOutboxWorker()` — poll run_outbox, publish in order, mark published
- Polling interval: 200ms (configurable)
- Batch size: 10 events per run (for efficiency)

### SSE API Update

- `packages/features/agents-run/src/infra/api/get-stream-run.ts`
- Parse `?fromSeq` query param
- Call `RunEventRepo.getUnpublishedEvents(runId, fromSeq)` for backfill
- Merge backfill + live stream with de-dupe

### Package Dependencies

- `packages/features/agents-run/package.json` — add `@repo/database: workspace:*`

## Invariants (Enforced)

1. **Unique (runId, seq):** DB constraint on run_events
2. **Monotonic seq:** runs.lastSeq only increments; append validates seq == lastSeq + 1
3. **Single publisher:** Only outbox sets `source='outbox'` and publishes to bus
4. **Payload-free:** Events remain canonical (no extra fields)
5. **Terminal once:** Only one RunFinished per run (DB check or app-level guard)
6. **Backfill order:** SSE backfill always ORDER BY seq
7. **De-dupe:** SSE tracks lastSentSeq; drops live events if seq <= lastSentSeq

## Tests (Incremental)

### After Schema + Repos

- **Unit (run-repo):** create run, update state, read lastSeq
- **Unit (run-event-repo):** append event (bumps lastSeq), duplicate (runId, seq) rejected, mark published
- **Unit (outbox-repo):** init outbox, getNextSeq, advanceSeq

### After Outbox Publisher

- **Integration (outbox):** insert 5 events → outbox publishes in order → all have publishedAt
- **Integration (concurrency):** two runs publish independently; no seq conflict
- **Integration (terminal):** RunFinished published → runs.state='finished'

### After SSE Backfill

- **Integration (backfill):** insert events directly → SSE with fromSeq=3 → receives events 4..N
- **Integration (de-dupe):** backfill event 5 → live event 5 arrives → only sent once
- **E2E (reconnect):** start run → disconnect after seq=3 → reconnect with fromSeq=3 → receive 4..RunFinished

### Manual Smoke Tests

- Checkpoint 1 (after repos): Verify events persist to DB with unique (runId, seq)
- Checkpoint 2 (after outbox): Verify events publish in order; bus receives sequenced events
- Checkpoint 3 (after SSE backfill): Verify reconnect with fromSeq works; no duplicates; terminal closes stream

## Migration Path

1. Add Prisma models
2. Run `pnpm --filter @repo/database generate` (zod schemas auto-gen)
3. Run `pnpm --filter @repo/database push` (apply to local DB)
4. CI: add migration step or use `prisma db push --accept-data-loss` for dev

## Docs to Update

- `packages/features/agents-run/README.md`: note persistence layer, outbox pattern, SSE backfill
- `docs/architecture/flow.md`: add M4 overlay (persist → outbox → bus → SSE)
- Add runbook snippet: "Run stuck" checklist (check run_outbox.nextSeq, run_events gaps)

## Founders Review

**New features creation:**

- Repositories live in `packages/features/agents-run/src/infra/repos/` (feature-level data access)
- Outbox publisher is a worker in `infra/workers/`
- Keep domain (`packages/agents-core`) unchanged

**Code flow:**

- Write path: orchestrator → tracer → repo.appendEvent → DB (no bus)
- Read path: outbox → repo.getUnpublishedEvents → bus.publish → repo.markPublished
- SSE: backfill (repo) + live (bus subscription) + de-dupe

**Naming:**

- Repos: PascalCase classes with camelCase methods (`RunEventRepo.appendEvent`)
- Workers: camelCase start functions (`startOutboxWorker`)
- DB tables: snake_case (`run_events`, `run_outbox`)

## M5 Readiness (No Implementation in M4)

- Schema supports additional event metadata (extend `run_events.meta` JSON field if needed)
- Outbox can batch publish for efficiency
- SSE can add compression/chunking
- Repos can add caching layer

---

## Implementation Todos

### Phase 1: Schema + Repos (Foundation)

- Add Prisma models (Run, RunEvent, RunOutbox)
- Generate Prisma client and Zod schemas
- Implement RunRepo (create, updateState, getLastSeq)
- Implement RunEventRepo (appendEvent, getUnpublishedEvents, markPublished)
- Implement OutboxRepo (initOutbox, getNextSeq, advanceSeq)
- **Test checkpoint:** Unit tests for repos (create, append, uniqueness, monotonic)
- **Smoke test 1:** Manually insert event via repo; verify in DB with psql/studio

### Phase 2: Persistence Integration (Write Path)

- Update FeatureLayerTracer to call RunEventRepo.appendEvent instead of bus.publish
- Update start-run to call RunRepo.createRun before emitting RunStarted
- Add RunOutbox.initOutbox call in start-run
- **Test checkpoint:** Integration test verifies events persist; no bus publish yet
- **Smoke test 2:** Run a job; verify run_events table has 13 events with unique (runId, seq)

### Phase 3: Outbox Publisher (Read Path)

- Implement outbox-publisher.ts worker (poll, lock, publish, mark, advance)
- Wire outbox worker to start alongside run-worker
- Set source='outbox' when publishing from outbox
- **Test checkpoint:** Integration test verifies outbox publishes in order; publishedAt set
- **Smoke test 3:** Start run; watch outbox publish events to bus; verify SSE receives them

### Phase 4: SSE Backfill (Reconnect)

- Update get-stream-run to parse ?fromSeq query param
- Implement backfill: query run_events WHERE seq > fromSeq AND publishedAt IS NOT NULL
- Add de-dupe logic: track lastSentSeq; drop live events if seq <= lastSentSeq
- **Test checkpoint:** Integration test simulates reconnect; backfill + live attach; no duplicates
- **Smoke test 4:** Start run; disconnect after event 5; reconnect with ?fromSeq=5; verify events 6..13

### Phase 5: Observability + Docs

- Add basic metrics: runs_started, runs_finished, events_persisted, outbox_lag_ms
- Create one-page runbook for "run stuck" scenarios
- Update flow.md with M4 persistence overlay
- Update agents-run README with persistence/outbox/backfill notes
- **Test checkpoint:** E2E test verifies full happy path (M2 parity)
- **Smoke test 5:** Full manual test with reconnect; verify metrics logged

### Phase 6: CI + Final Gates

- Run pr:check (lint, type, unit, integration, e2e)
- Verify no schema regressions
- Ensure migrations work in CI
- **Test checkpoint:** All tests green; coverage thresholds met

### To-dos

- [ ] Create ports and canonical types under packages/agent/src/ports
- [ ] Implement pure node functions and results for 5 nodes
- [ ] Add errors and policies modules for timeouts
- [ ] Define linear plan and build-graph binding
- [ ] Implement orchestrateRun with emissions, timeouts, cancellation
- [ ] Wire feature worker to orchestrateRun with in-memory adapters
- [ ] Add unit tests for nodes (emits DebugTrace; returns)
- [ ] Add unit tests for orchestrator ordering, cancel, error path
- [ ] Add integration test: golden path parity; dual-run concurrency
- [ ] Update README and architecture flow notes per M3
- [ ] Run lint, typecheck, unit, affected e2e; keep stream schema unchanged